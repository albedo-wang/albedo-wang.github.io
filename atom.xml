<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>望秋弥茂の妙妙屋</title>
  
  <subtitle>松柏之质 经霜弥茂</subtitle>
  <link href="https://wangqiumimao.ink/atom.xml" rel="self"/>
  
  <link href="https://wangqiumimao.ink/"/>
  <updated>2023-01-10T03:39:22.315Z</updated>
  <id>https://wangqiumimao.ink/</id>
  
  <author>
    <name>望秋弥茂</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>标签外挂</title>
    <link href="https://wangqiumimao.ink/posts/54667693.html"/>
    <id>https://wangqiumimao.ink/posts/54667693.html</id>
    <published>2023-01-04T09:23:21.000Z</published>
    <updated>2023-01-10T03:39:22.315Z</updated>
    
    <content type="html"><![CDATA[<h1 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h1><div class="tip "><p>default</p></div><div class="tip info"><p>info</p></div><div class="tip success"><p>success</p></div><div class="tip error"><p>error</p></div><div class="tip warning"><p>warning</p></div><div class="tip bolt"><p>bolt</p></div><div class="tip ban"><p>ban</p></div><div class="tip home"><p>home</p></div><div class="tip sync"><p>sync</p></div><div class="tip cogs"><p>cogs</p></div><div class="tip key"><p>key</p></div><div class="tip bell"><p>bell</p></div><div class="tip fa-atom"><p>自定义font awesome图标</p></div><h1 id="标签外挂"><a href="#标签外挂" class="headerlink" title="标签外挂"></a>标签外挂</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip %&#125;default&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip info %&#125;info&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip success %&#125;success&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip error %&#125;error&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip warning %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip bolt %&#125;bolt&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban %&#125;ban&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip home %&#125;home&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip sync %&#125;sync&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip cogs %&#125;cogs&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip key %&#125;key&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip bell %&#125;bell&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip fa-atom %&#125;自定义font awesome图标&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;效果预览&quot;&gt;&lt;a href=&quot;#效果预览&quot; class=&quot;headerlink&quot; title=&quot;效果预览&quot;&gt;&lt;/a&gt;效果预览&lt;/h1&gt;&lt;div class=&quot;tip &quot;&gt;&lt;p&gt;default&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;tip info&quot;&gt;&lt;p&gt;</summary>
      
    
    
    
    <category term="博客搭建" scheme="https://wangqiumimao.ink/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="博客搭建" scheme="https://wangqiumimao.ink/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>CV Project2: Feature Detection and Matching</title>
    <link href="https://wangqiumimao.ink/posts/4140e37c.html"/>
    <id>https://wangqiumimao.ink/posts/4140e37c.html</id>
    <published>2022-08-14T08:02:11.000Z</published>
    <updated>2023-01-10T03:38:41.433Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h1><blockquote><p>​    This project contains the <strong>feature detection and matching two parts</strong>. My teammates deal with the first problem. The matching part is my task. </p><p>​    <strong>The feature detection need us to use the definition to solve it and do not be allowed to use the package function in third lib.</strong></p><p>​    So we start from the <strong>Harris corner detection.</strong> </p><p>​    Then use various feature descriptions:</p><ul><li><p>[x] <strong>Simple Description</strong></p></li><li><p>[x] <strong>MOPS (Multiscale Oriented Patches descriptor)</strong></p></li><li><p>[x] <strong>ORB (Oriented FAST and Rotated BRIEF)</strong></p></li><li>[ ] <strong>SIFT (Scale-invariant feature transform)</strong></li></ul><p>​    After the feature detection, it’s my work to solve the matching problem.</p></blockquote><h1 id="Feature-Detection"><a href="#Feature-Detection" class="headerlink" title="Feature Detection"></a>Feature Detection</h1><blockquote><p>​    <strong>This part is left for future edition. (Lazy man!)</strong></p></blockquote><h1 id="Feature-Matching"><a href="#Feature-Matching" class="headerlink" title="Feature Matching"></a>Feature Matching</h1><blockquote><p>​    Before matching, the choice of <strong>measurement between descriptors</strong> is of great significance.</p><p>​    A common method is to <strong>calculate the distance of two descriptors</strong>.</p></blockquote><h2 id="How-to-calculate-the-difference-of-two-descriptors"><a href="#How-to-calculate-the-difference-of-two-descriptors" class="headerlink" title="How to calculate the difference of two descriptors?"></a>How to calculate the difference of two descriptors?</h2><blockquote><ul><li>[ ] <strong>MAD Algorithm (Mean Absolute Differences):</strong></li></ul></blockquote><script type="math/tex; mode=display">D(i,j)=\frac{1}{M+N}\sum_{s=1}^M\sum_{t=1}^N|S(i+s-1,j+t-1)-T(s,t)|</script><blockquote><ul><li>[ ] <strong>SAD Algorithm (Sum of Absolute Differences):</strong></li></ul></blockquote><script type="math/tex; mode=display">D(i,j)=\sum_{s=1}^M\sum_{t=1}^N|S(i+s-1,j+t-1)-T(s,t)|</script><blockquote><ul><li>[x] <strong>SSD Algorithm (Sum of Squared Differences):</strong></li></ul></blockquote><script type="math/tex; mode=display">D(i,j)=\sum_{s=1}^M\sum_{t=1}^N|S(i+s-1,j+t-1)-T(s,t)|^2</script><blockquote><ul><li>[ ] <strong>MSD Algorithm (Mean Square Differences):</strong></li></ul></blockquote><script type="math/tex; mode=display">D(i,j)=\sum_{s=1}^M\sum_{t=1}^N|S(i+s-1,j+t-1)-T(s,t)|^2</script><blockquote><ul><li>[ ] <strong>NCC Algorithm (Normalized Cross Correlation):</strong></li></ul></blockquote><script type="math/tex; mode=display">R(i,j)=\frac{\sum_{s=1}^M\sum_{t=1}^N|S^{i,j}(s,t)-E^{i,j}(s,t)||T(s,t)-E(T)|}{\sqrt{\sum_{s=1}^M\sum_{t=1}^N[S^{i,j}(s,t)-E^{i,j}(s,t)]^2\sum_{s=1}^M\sum_{t=1}^N[T(s,t)-E(T)]^2}}</script><h2 id="Match-Policy"><a href="#Match-Policy" class="headerlink" title="Match Policy"></a>Match Policy</h2><h3 id="Descriptor-Distance-Matrix"><a href="#Descriptor-Distance-Matrix" class="headerlink" title="Descriptor Distance Matrix"></a>Descriptor Distance Matrix</h3><blockquote><p>​        For the convenience of the following algorithm, I first store all the distance between the two pictures’ descriptors in a so called Distance Matrix.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Calculate the ssd between the two picture&#x27;s descriptors list(stored the positions of descriptors)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ssd_map</span>(<span class="params">des1, des2</span>):</span><br><span class="line">    m, n = <span class="built_in">len</span>(des1), <span class="built_in">len</span>(des2)</span><br><span class="line">    distance = np.zeros((m, n))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n):</span><br><span class="line">            distance[i][j] = np.<span class="built_in">sum</span>((des1[i] - des2[j]) ** <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> distance</span><br></pre></td></tr></table></figure><h3 id="Minimum-SSD-Match"><a href="#Minimum-SSD-Match" class="headerlink" title="Minimum SSD Match"></a>Minimum SSD Match</h3><blockquote><p>​        <strong>Function_name: ssd_double_check</strong></p><p>​        According to the SSD algorithm mentioned in 3.1 part, the match policy is to match the descriptor in one picture with the minimum distance descriptor from another picture.</p><p>​        <strong>It seems that this is the end of this part. But please think for a while.</strong> If just do the match policy from picture 1 to picture 2, the final outcome must be that all descriptors in picture 1 have the one so called matched descriptors in picture 2.</p><p>​        No matter the descriptors detected in two pictures having whatever quantitative relationship. <strong>The worst way for the match descriptors in picture 2 may have connect to more than one descriptor in picture 1. It is unreasonable.</strong></p><p>​        One way to avoid this problem is to <strong>do the match procedure twice from picture 1 to picture 2 and also for picture 2 to picture 1</strong>. If both check is the same match pair, the match is legal. Otherwise, the match outcome shall be abandoned.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The match policy is that the descriptor pair has the min ssd</span></span><br><span class="line"><span class="comment"># Also check in both picture&#x27;s descriptors</span></span><br><span class="line"><span class="comment"># Thus making sure that the match between the two picture&#x27;s descriptors is single mapping</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ssd_double_check</span>(<span class="params">des1, des2</span>):</span><br><span class="line">    match_des = []</span><br><span class="line">    dis_map = ssd_map(des1, des2)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(des1)):</span><br><span class="line">        <span class="comment"># Return the min ssd match index in descriptor2 of the descriptor1</span></span><br><span class="line">        min_2to1 = np.argmin(dis_map[i, :])</span><br><span class="line">        <span class="comment"># Return the min ssd match index in descriptor1 of the descriptor2</span></span><br><span class="line">        min_1to2 = np.argmin(dis_map[:, min_2to1])</span><br><span class="line">        <span class="comment"># Make sure the match is single mapping</span></span><br><span class="line">        <span class="keyword">if</span> min_1to2 == i:</span><br><span class="line">            match_des.append((i, min_2to1))</span><br><span class="line">    <span class="keyword">return</span> match_des</span><br></pre></td></tr></table></figure><h3 id="Ratio-SSD-match"><a href="#Ratio-SSD-match" class="headerlink" title="Ratio SSD match"></a>Ratio SSD match</h3><blockquote><p>​        <strong>Function_name:  ratio_test</strong><br>​        After do the minimum SSD match, one more supporting measure carried out. The minimum SSD should also satisfy <strong>that is smaller than a certain and appropriate ratio multiply the second minimum SSD.</strong></p></blockquote><center><img src = "https://cdn.staticaly.com/gh/albedo-wang/picgo@main/img/20230105135040.png" style = "zoom: 67%;" /></center><blockquote><p>​        Fixed threshold, nearest neighbor, and nearest neighbor distance ratio matching. At a fixed distance threshold (dashed circles), descriptor D<sub>A</sub> fails to match D<sub>B</sub> and D<sub>D</sub> incorrectly matches D<sub>C</sub> and D<sub>E</sub>. If we pick the nearest neighbor, D<sub>A</sub> correctly matches D<sub>B</sub> but D<sub>D</sub> incorrectly matches D<sub>C</sub>. Using nearest neighbor distance ratio (NNDR) matching, the small NNDR d<sub>1</sub> = d<sub>2</sub> correctly matches D<sub>A</sub> with D<sub>B</sub>, and the large NNDR d<sub>1</sub>‘ = d<sub>2</sub>‘ correctly rejects matches for D<sub>D</sub>.<br>​        <strong>The ratio is nearest neighbor distance ratio (NNDR):</strong></p><script type="math/tex; mode=display">NNDR = \frac{d_1}{d_2} = \frac{||D_A-D_B||}{||D_A-D_C||}</script><center>(d<sub>1</sub> - Nearest neighbor distance, d<sub>2</sub> - Next neighbor distance)</center><center>(D<sub>A</sub> - Goal Descriptor, D<sub>B</sub>, D<sub>C</sub> - The nearest two neighbors)</center><p>​        <strong>In the code part, the ratio set is 0.65.</strong> Due to the use of nearest neighbor distance and next neighbor distance, code part defines a ssd_map function to return all the distance between the descriptors in the given two pictures. It is convenient for the NNDR calculation and following comparing with the 0.65 for the reason that the nearest two distance can be easily obtained in the ssd_map.</p><p>​        Finally, the twice check should be carried out to make sure the match answer is appropriate.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The match policy is that the min1 ssd is smaller than a constant multiplies the min2 ssd</span></span><br><span class="line"><span class="comment"># Also check in both picture&#x27;s descriptors</span></span><br><span class="line"><span class="comment"># Thus making sure that the match between the two picture&#x27;s descriptors is single mapping</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ratio_test</span>(<span class="params">des1, des2</span>):</span><br><span class="line">    match_des = []</span><br><span class="line">    dis_map = ssd_map(des1, des2)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(des1)):</span><br><span class="line">        sort_dis1 = np.sort(dis_map[i, :])</span><br><span class="line">        <span class="comment"># Get the min1 and min2 ssd</span></span><br><span class="line">        min11, min12 = sort_dis1[<span class="number">0</span>], sort_dis1[<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># Get the min ssd index in descriptors2 to descriptors1</span></span><br><span class="line">        min_2to1 = np.argmin(dis_map[i, :])</span><br><span class="line">        <span class="comment"># The ratio set is 0.65 and check in two direction</span></span><br><span class="line">        <span class="keyword">if</span> min11 &lt;= <span class="number">0.65</span> * min12:</span><br><span class="line">            sort_dis2 = np.sort(dis_map[:, min_2to1])</span><br><span class="line">            min21, min22 = sort_dis2[<span class="number">0</span>], sort_dis2[<span class="number">1</span>]</span><br><span class="line">            min_1to2 = np.argmin(dis_map[:, min_2to1])</span><br><span class="line">            <span class="comment"># Check twice in two direction to make sure the match is best between two descriptors</span></span><br><span class="line">            <span class="keyword">if</span> min21 &lt;= <span class="number">0.65</span> * min22 <span class="keyword">and</span> min_1to2 == i:</span><br><span class="line">                match_des.append((i, min_2to1))</span><br><span class="line">    <span class="keyword">return</span> match_des</span><br></pre></td></tr></table></figure><h3 id="Draw-Match"><a href="#Draw-Match" class="headerlink" title="Draw Match"></a>Draw Match</h3><blockquote><p>​        <strong>Function_name:  draw_match_simple, draw_match_mops.</strong></p><p>​        First, it is obvious that those three descriptor methods are different with each other. So the descriptor drawing has to be consider in three case. Simple descriptors can be draw with cv2.rectangle function. While MOPS descriptors are a bit more difficult due to the rotated rectangle. Noticing that no build-in function in cv2 lib, one simplest method to draw is to get the four points to draw line one by one.</p><p>​        In the code part, the return value from MOPSdescriptor function are the descriptor intensity and angles of them. According to the math transformation, it is easy to gain the position of the four points (var_name: coord1, coord2, coor3, coor4).</p><p>​        Besides, for the matched descriptors in two pictures, the color of the rectangle is red. Nonmatched is blue. Thus, it is apparent to see the match result.</p></blockquote><p>PS：<strong>The following code may be so funny.</strong> I don’t use the square method to draw and do it by lines’ connection.</p><p>​        In that time, I search that <strong>there is no existing method</strong> to draw a <strong>rotated square zoom</strong> in the picture.</p><p>​        ==<strong>(Perhaps there is the method for now or you are clever to solve the problem in a simple way.)</strong>==</p><p>​        So, I typed the following <strong>stupid code</strong> and submitted.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Draw match outcome part</span></span><br><span class="line"><span class="comment"># Get the match index pairs earlier returned</span></span><br><span class="line"><span class="comment"># Do the picture stitching</span></span><br><span class="line"><span class="comment"># Draw descriptors and the line to connect the matched descriptors</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">draw_match_simple</span>(<span class="params">img1, img2, kps1, kps2, <span class="keyword">match</span></span>):</span><br><span class="line">    im_1 = cv2.imread(img1)</span><br><span class="line">    im_2 = cv2.imread(img2)</span><br><span class="line">    h1, w1, c1 = np.shape(im_1)</span><br><span class="line">    h2, w2, c2 = np.shape(im_2)</span><br><span class="line">    <span class="comment"># picture stitching</span></span><br><span class="line">    compose = np.zeros((h1, w1 + w2, <span class="number">3</span>))</span><br><span class="line">    compose[<span class="number">0</span>:h1, <span class="number">0</span>:w1, :] = im_1</span><br><span class="line">    compose[<span class="number">0</span>:h1, w1:w1 + w2, :] = im_2</span><br><span class="line">    compose = compose.astype(np.uint8)</span><br><span class="line">    <span class="comment"># draw descriptors and match lines</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(kps1)):</span><br><span class="line">        kp1_y, kp1_x = kps1[j]</span><br><span class="line">        cv2.rectangle(compose, (kp1_x - <span class="number">2</span>, kp1_y - <span class="number">2</span>), (kp1_x + <span class="number">2</span>, kp1_y + <span class="number">2</span>), (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(kps2)):</span><br><span class="line">        kp2_y, kp2_x = kps2[k]</span><br><span class="line">        cv2.rectangle(compose, (kp2_x - <span class="number">2</span> + w1, kp2_y - <span class="number">2</span>), (kp2_x + <span class="number">2</span> + w1, kp2_y + <span class="number">2</span>), (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(<span class="keyword">match</span>)):</span><br><span class="line">        kp1_idx, kp2_idx = <span class="keyword">match</span>[i]</span><br><span class="line">        kp1_y, kp1_x = kps1[kp1_idx]</span><br><span class="line">        kp2_y, kp2_x = kps2[kp2_idx]</span><br><span class="line">        cv2.rectangle(compose, (kp1_x - <span class="number">2</span>, kp1_y - <span class="number">2</span>), (kp1_x + <span class="number">2</span>, kp1_y + <span class="number">2</span>), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">1</span>)</span><br><span class="line">        cv2.rectangle(compose, (kp2_x - <span class="number">2</span> + w1, kp2_y - <span class="number">2</span>), (kp2_x + <span class="number">2</span> + w1, kp2_y + <span class="number">2</span>), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">1</span>)</span><br><span class="line">        cv2.line(compose, (kp1_x, kp1_y), (kp2_x + w1, kp2_y), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">1</span>)</span><br><span class="line">    cv2.imshow(<span class="string">&#x27;match_img&#x27;</span>, compose)</span><br><span class="line">    name = <span class="string">&#x27;Match_Time_&#x27;</span> + time.strftime(<span class="string">&#x27;%H-%M-%S&#x27;</span>) + <span class="string">&#x27;.jpg&#x27;</span></span><br><span class="line">    cv2.imwrite(name, compose)</span><br><span class="line">    cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">    cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">draw_match_mops</span>(<span class="params">img1, img2, kps1, kps2, <span class="keyword">match</span>, angle1, angle2</span>):</span><br><span class="line">    im_1 = cv2.imread(img1)</span><br><span class="line">    im_2 = cv2.imread(img2)</span><br><span class="line">    h1, w1, c1 = np.shape(im_1)</span><br><span class="line">    h2, w2, c2 = np.shape(im_2)</span><br><span class="line">    <span class="comment"># picture stitching</span></span><br><span class="line">    compose = np.zeros((h1, w1 + w2, <span class="number">3</span>))</span><br><span class="line">    compose[<span class="number">0</span>:h1, <span class="number">0</span>:w1, :] = im_1</span><br><span class="line">    compose[<span class="number">0</span>:h1, w1:w1 + w2, :] = im_2</span><br><span class="line">    compose = compose.astype(np.uint8)</span><br><span class="line">    <span class="comment"># draw descriptors and match lines</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(kps1)):</span><br><span class="line">        kp1_y, kp1_x = kps1[j]</span><br><span class="line">        coord1 = (kp1_x - <span class="built_in">int</span>(<span class="number">5</span> * math.cos((angle1[j] - <span class="number">45</span>)/<span class="number">180</span>)), kp1_y + <span class="built_in">int</span>(<span class="number">5</span> * math.sin((angle1[j] - <span class="number">45</span>)/<span class="number">180</span>)))</span><br><span class="line">        coord2 = (kp1_x - <span class="built_in">int</span>(<span class="number">5</span> * math.sin((angle1[j] - <span class="number">45</span>)/<span class="number">180</span>)), kp1_y - <span class="built_in">int</span>(<span class="number">5</span> * math.cos((angle1[j] - <span class="number">45</span>)/<span class="number">180</span>)))</span><br><span class="line">        coord3 = (kp1_x + <span class="built_in">int</span>(<span class="number">5</span> * math.cos((angle1[j] - <span class="number">45</span>)/<span class="number">180</span>)), kp1_y - <span class="built_in">int</span>(<span class="number">5</span> * math.sin((angle1[j] - <span class="number">45</span>)/<span class="number">180</span>)))</span><br><span class="line">        coord4 = (kp1_x + <span class="built_in">int</span>(<span class="number">5</span> * math.sin((angle1[j] - <span class="number">45</span>)/<span class="number">180</span>)), kp1_y + <span class="built_in">int</span>(<span class="number">5</span> * math.cos((angle1[j] - <span class="number">45</span>)/<span class="number">180</span>)))</span><br><span class="line">        cv2.line(compose, coord1, coord2, (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">1</span>)</span><br><span class="line">        cv2.line(compose, coord2, coord3, (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">1</span>)</span><br><span class="line">        cv2.line(compose, coord3, coord4, (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">1</span>)</span><br><span class="line">        cv2.line(compose, coord4, coord1, (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(kps2)):</span><br><span class="line">        kp2_y, kp2_x = kps2[k]</span><br><span class="line">        coord1 = (kp2_x - <span class="built_in">int</span>(<span class="number">5</span> * math.cos((angle2[k] - <span class="number">45</span>)/<span class="number">180</span>)) + w1, kp2_y + <span class="built_in">int</span>(<span class="number">5</span> * math.sin((angle2[k] - <span class="number">45</span>)/<span class="number">180</span>)))</span><br><span class="line">        coord2 = (kp2_x - <span class="built_in">int</span>(<span class="number">5</span> * math.sin((angle2[k] - <span class="number">45</span>)/<span class="number">180</span>)) + w1, kp2_y - <span class="built_in">int</span>(<span class="number">5</span> * math.cos((angle2[k] - <span class="number">45</span>)/<span class="number">180</span>)))</span><br><span class="line">        coord3 = (kp2_x + <span class="built_in">int</span>(<span class="number">5</span> * math.cos((angle2[k] - <span class="number">45</span>)/<span class="number">180</span>)) + w1, kp2_y - <span class="built_in">int</span>(<span class="number">5</span> * math.sin((angle2[k] - <span class="number">45</span>)/<span class="number">180</span>)))</span><br><span class="line">        coord4 = (kp2_x + <span class="built_in">int</span>(<span class="number">5</span> * math.sin((angle2[k] - <span class="number">45</span>)/<span class="number">180</span>)) + w1, kp2_y + <span class="built_in">int</span>(<span class="number">5</span> * math.cos((angle2[k] - <span class="number">45</span>)/<span class="number">180</span>)))</span><br><span class="line">        cv2.line(compose, coord1, coord2, (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">1</span>)</span><br><span class="line">        cv2.line(compose, coord2, coord3, (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">1</span>)</span><br><span class="line">        cv2.line(compose, coord3, coord4, (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">1</span>)</span><br><span class="line">        cv2.line(compose, coord4, coord1, (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(<span class="keyword">match</span>)):</span><br><span class="line">        kp1_idx, kp2_idx = <span class="keyword">match</span>[i]</span><br><span class="line">        kp1_y, kp1_x = kps1[kp1_idx]</span><br><span class="line">        kp2_y, kp2_x = kps2[kp2_idx]</span><br><span class="line">        coord1 = (kp1_x - <span class="built_in">int</span>(<span class="number">5</span> * math.cos((angle1[i] - <span class="number">45</span>)/<span class="number">180</span>)), kp1_y + <span class="built_in">int</span>(<span class="number">5</span> * math.sin((angle1[i] - <span class="number">45</span>)/<span class="number">180</span>)))</span><br><span class="line">        coord2 = (kp1_x - <span class="built_in">int</span>(<span class="number">5</span> * math.sin((angle1[i] - <span class="number">45</span>)/<span class="number">180</span>)), kp1_y - <span class="built_in">int</span>(<span class="number">5</span> * math.cos((angle1[i] - <span class="number">45</span>)/<span class="number">180</span>)))</span><br><span class="line">        coord3 = (kp1_x + <span class="built_in">int</span>(<span class="number">5</span> * math.cos((angle1[i] - <span class="number">45</span>)/<span class="number">180</span>)), kp1_y - <span class="built_in">int</span>(<span class="number">5</span> * math.sin((angle1[i] - <span class="number">45</span>)/<span class="number">180</span>)))</span><br><span class="line">        coord4 = (kp1_x + <span class="built_in">int</span>(<span class="number">5</span> * math.sin((angle1[i] - <span class="number">45</span>)/<span class="number">180</span>)), kp1_y + <span class="built_in">int</span>(<span class="number">5</span> * math.cos((angle1[i] - <span class="number">45</span>)/<span class="number">180</span>)))</span><br><span class="line">        cv2.line(compose, coord1, coord2, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">1</span>)</span><br><span class="line">        cv2.line(compose, coord2, coord3, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">1</span>)</span><br><span class="line">        cv2.line(compose, coord3, coord4, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">1</span>)</span><br><span class="line">        cv2.line(compose, coord4, coord1, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">1</span>)</span><br><span class="line">        coord1 = (kp2_x - <span class="built_in">int</span>(<span class="number">5</span> * math.cos((angle2[i] - <span class="number">45</span>)/<span class="number">180</span>)) + w1, kp2_y + <span class="built_in">int</span>(<span class="number">5</span> * math.sin((angle2[i] - <span class="number">45</span>)/<span class="number">180</span>)))</span><br><span class="line">        coord2 = (kp2_x - <span class="built_in">int</span>(<span class="number">5</span> * math.sin((angle2[i] - <span class="number">45</span>)/<span class="number">180</span>)) + w1, kp2_y - <span class="built_in">int</span>(<span class="number">5</span> * math.cos((angle2[i] - <span class="number">45</span>)/<span class="number">180</span>)))</span><br><span class="line">        coord3 = (kp2_x + <span class="built_in">int</span>(<span class="number">5</span> * math.cos((angle2[i] - <span class="number">45</span>)/<span class="number">180</span>)) + w1, kp2_y - <span class="built_in">int</span>(<span class="number">5</span> * math.sin((angle2[i] - <span class="number">45</span>)/<span class="number">180</span>)))</span><br><span class="line">        coord4 = (kp2_x + <span class="built_in">int</span>(<span class="number">5</span> * math.sin((angle2[i] - <span class="number">45</span>)/<span class="number">180</span>)) + w1, kp2_y + <span class="built_in">int</span>(<span class="number">5</span> * math.cos((angle2[i] - <span class="number">45</span>)/<span class="number">180</span>)))</span><br><span class="line">        cv2.line(compose, coord1, coord2, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">1</span>)</span><br><span class="line">        cv2.line(compose, coord2, coord3, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">1</span>)</span><br><span class="line">        cv2.line(compose, coord3, coord4, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">1</span>)</span><br><span class="line">        cv2.line(compose, coord4, coord1, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">1</span>)</span><br><span class="line">        cv2.line(compose, (kp1_x, kp1_y), (kp2_x + w1, kp2_y), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">1</span>)</span><br><span class="line">    cv2.imshow(<span class="string">&#x27;match_img&#x27;</span>, compose)</span><br><span class="line">    name = <span class="string">&#x27;Match_Time_&#x27;</span> + time.strftime(<span class="string">&#x27;%H-%M-%S&#x27;</span>) + <span class="string">&#x27;.jpg&#x27;</span></span><br><span class="line">    cv2.imwrite(name, compose)</span><br><span class="line">    cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">    cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Goal&quot;&gt;&lt;a href=&quot;#Goal&quot; class=&quot;headerlink&quot; title=&quot;Goal&quot;&gt;&lt;/a&gt;Goal&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;​    This project contains the &lt;strong&gt;feature de</summary>
      
    
    
    
    <category term="视觉" scheme="https://wangqiumimao.ink/categories/%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="CV" scheme="https://wangqiumimao.ink/tags/CV/"/>
    
  </entry>
  
  <entry>
    <title>CV Project1: Hybrid Image</title>
    <link href="https://wangqiumimao.ink/posts/3c60861f.html"/>
    <id>https://wangqiumimao.ink/posts/3c60861f.html</id>
    <published>2022-08-11T06:44:30.000Z</published>
    <updated>2023-01-10T03:38:46.359Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>​        The goal of this assignment is to write an image filtering function and use it to create hybrid images. Hybrid images are static images that change in interpretation as a function of the viewing distance. The basic idea is that high frequency tends to dominate perception when it is available, but, at a distance, only the low frequency (smooth) part of the signal can be seen. By blending the high frequency portion of one image with the low-frequency portion of another, you get a hybrid image that leads to different interpretations at different distances. You will use your own solution to create your own hybrid images.</p><h1 id="Implementation-Details"><a href="#Implementation-Details" class="headerlink" title="Implementation Details"></a>Implementation Details</h1><h2 id="cross-correlation-2d"><a href="#cross-correlation-2d" class="headerlink" title="cross_correlation_2d"></a>cross_correlation_2d</h2><p>​            Realize the math function of cross correlation.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cross_correlation_2d</span>(<span class="params">kernel, img</span>):</span><br><span class="line">    m, n = np.shape(kernel)</span><br><span class="line">    row, col = np.shape(img)</span><br><span class="line">    pad_num = m // <span class="number">2</span></span><br><span class="line">    ans = np.zeros((row-<span class="number">2</span>*pad_num, col-<span class="number">2</span>*pad_num))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(pad_num, row-pad_num):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(pad_num, col-pad_num):</span><br><span class="line">            cal_matrix = img[i-pad_num:i+pad_num+<span class="number">1</span>, j-pad_num:j+pad_num+<span class="number">1</span>]</span><br><span class="line">            dot_ans = np.multiply(kernel, cal_matrix)</span><br><span class="line">            ans[i-pad_num][j-pad_num] = dot_ans.<span class="built_in">sum</span>()</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h2 id="convolve-2d"><a href="#convolve-2d" class="headerlink" title="convolve_2d"></a>convolve_2d</h2><p>​            Realize the math function of convolution.</p><p>​            One simple but maybe cost much way is to turn the kernel element in inverse order</p><p>​            then use the cross_correlation_2d function.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">convolve_2d</span>(<span class="params">kernel, img</span>):</span><br><span class="line">    m, n = np.shape(kernel)</span><br><span class="line">    convolve_kernel = np.zeros((m, n))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            convolve_kernel[i][j] = kernel[m-i-<span class="number">1</span>][n-j-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> cross_correlation_2d(convolve_kernel, img)</span><br></pre></td></tr></table></figure><h2 id="gaussian-blur-kernel-2d"><a href="#gaussian-blur-kernel-2d" class="headerlink" title="gaussian_blur_kernel_2d"></a>gaussian_blur_kernel_2d</h2><blockquote><p>Generate a 2 dimension gaussian blur kernel.</p><p>One way is to use the math lib and do the calculation of gaussian distribution (The below code is this way).</p><p>Another better way is to use cv2.getGaussianKernel() to generate a 1 dimension vector, then do the vector multiplication to get a 2 dimension kernel.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gaussian_blur_kernel_2d</span>(<span class="params">n, sigma</span>):  <span class="comment"># n kernel size</span></span><br><span class="line">    <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&quot;Please enter a odd number for the gaussian filter!&quot;</span>)  </span><br><span class="line">        <span class="comment"># Here is a error warning set by myself to make sure that can remind me of the kernel size is odd!</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        temp_kernel = np.zeros((n, n))</span><br><span class="line">        center = n // <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                temp_kernel[i][j] = math.exp(-((i - center + <span class="number">1</span>) ** <span class="number">2</span> + (j - center + <span class="number">1</span>) ** <span class="number">2</span>) / (<span class="number">2</span> * sigma ** <span class="number">2</span>))</span><br><span class="line">        kernel = temp_kernel / temp_kernel.<span class="built_in">sum</span>()</span><br><span class="line">    <span class="keyword">return</span> kernel</span><br></pre></td></tr></table></figure><h2 id="low-pass"><a href="#low-pass" class="headerlink" title="low_pass"></a>low_pass</h2><blockquote><p>Use the gaussian kernel to do the convolution, then get the low pass frequency image.</p><p>First, divide the r,g,b channels. </p><p>Then, use the pad function to pad image. </p><p>After, do the convolution. </p><p>Finally, merge them in one RGB image.</p></blockquote>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">low_pass</span>(<span class="params">img1, n, sigma</span>):  <span class="comment">#img1: input image, n: kernel size, sigma: gaussian kernel sigma</span></span><br><span class="line">    img = cv2.imread(img1)</span><br><span class="line">    b, g, r = cv2.split(img)</span><br><span class="line">    pad_num = n // <span class="number">2</span></span><br><span class="line">    kernel = gaussian_blur_kernel_2d(n, sigma)</span><br><span class="line">    padded_b = np.pad(b, ((pad_num, pad_num), (pad_num, pad_num)), <span class="string">&#x27;constant&#x27;</span>)</span><br><span class="line">    padded_g = np.pad(g, ((pad_num, pad_num), (pad_num, pad_num)), <span class="string">&#x27;constant&#x27;</span>)</span><br><span class="line">    padded_r = np.pad(r, ((pad_num, pad_num), (pad_num, pad_num)), <span class="string">&#x27;constant&#x27;</span>)</span><br><span class="line">    b = convolve_2d(kernel, padded_b)</span><br><span class="line">    g = convolve_2d(kernel, padded_g)</span><br><span class="line">    r = convolve_2d(kernel, padded_r)</span><br><span class="line">    low_pass_img = cv2.merge([b, g, r])</span><br><span class="line">    <span class="keyword">return</span> low_pass_img.astype(np.uint8)</span><br><span class="line">    <span class="comment"># np.uint8 make sure all the convolution element is integer number!</span></span><br></pre></td></tr></table></figure><h2 id="high-pass"><a href="#high-pass" class="headerlink" title="high_pass"></a>high_pass</h2><blockquote><p>Use the low pass image of the last function return. Then, do the subtraction to get the high pass image.</p><p>First, divide the r,g,b channels. </p><p>Then, use the pad function to pad image. </p><p>After, do the convolution. </p><p>Finally, merge them in one RGB image</p></blockquote>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">high_pass</span>(<span class="params">img2, n, sigma</span>): <span class="comment">#img2: input image, n: kernel size, sigma: gaussian kernel sigma</span></span><br><span class="line">    blur_img = low_pass(img2, n, sigma)</span><br><span class="line">    img = cv2.imread(img2)</span><br><span class="line">    high_pass_img = img - blur_img + <span class="number">128</span></span><br><span class="line">    <span class="keyword">return</span> high_pass_img</span><br><span class="line">    <span class="comment"># Due to the low pass image is 0-255 integer, this return do not need the np.uint8!</span></span><br></pre></td></tr></table></figure><h2 id="hybrid"><a href="#hybrid" class="headerlink" title="hybrid"></a>hybrid</h2><blockquote><p>Use the low pass image and high pass image. </p><p>Then, according to the setted Mix-in ratio to combine them.</p><p>The original function of hybrid (Don’t append any other method).</p></blockquote>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hybrid</span>(<span class="params">img1, img2, n, sigma, alpha</span>):</span><br><span class="line">    <span class="comment">#img1: left image(low pass frequency), img2: right image(high pass frequency), alpha: Mix-in ratio</span></span><br><span class="line">    low_pass_img = low_pass(img1, n, sigma)</span><br><span class="line">    high_pass_img = high_pass(img2, n, sigma)</span><br><span class="line">    hybrid_img = alpha * low_pass_img + (<span class="number">1</span> - alpha) * high_pass_img</span><br><span class="line">    hybrid_img = hybrid_img.astype(np.uint8)</span><br><span class="line">    <span class="keyword">return</span> hybrid_img</span><br></pre></td></tr></table></figure><blockquote><p>Use the global equalizehist.</p></blockquote>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hybrid</span>(<span class="params">img1, img2, n, sigma, alpha</span>):</span><br><span class="line">    <span class="comment">#img1: left image(low pass frequency), img2: right image(high pass frequency), alpha: Mix-in ratio</span></span><br><span class="line">    low_pass_img = low_pass(img1, n, sigma)</span><br><span class="line">    high_pass_img = high_pass(img2, n, sigma)</span><br><span class="line">    hybrid_img = alpha * low_pass_img + (<span class="number">1</span> - alpha) * high_pass_img</span><br><span class="line">    hybrid_img = hybrid_img.astype(np.uint8)</span><br><span class="line">    b, g, r = cv2.split(hybrid_img)</span><br><span class="line">    global_hist_b = cv2.equalizeHist(b)</span><br><span class="line">    global_hist_g = cv2.equalizeHist(g)</span><br><span class="line">    global_hist_r = cv2.equalizeHist(r)</span><br><span class="line">    <span class="keyword">return</span> cv2.merge([global_hist_b, global_hist_g, global_hist_r])</span><br></pre></td></tr></table></figure><blockquote><p>Use the local equlizehist.</p></blockquote>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hybrid</span>(<span class="params">img1, img2, n, sigma, alpha</span>):</span><br><span class="line">    <span class="comment">#img1: left image(low pass frequency), img2: right image(high pass frequency), alpha: Mix-in ratio</span></span><br><span class="line">    low_pass_img = low_pass(img1, n, sigma)</span><br><span class="line">    high_pass_img = high_pass(img2, n, sigma)</span><br><span class="line">    hybrid_img = alpha * low_pass_img + (<span class="number">1</span> - alpha) * high_pass_img</span><br><span class="line">    hybrid_img = hybrid_img.astype(np.uint8)</span><br><span class="line">    b, g, r = cv2.split(hybrid_img)</span><br><span class="line">    clahe = cv2.createCLAHE(<span class="number">1.5</span>, (<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">    local_hist_b = clahe.apply(b)</span><br><span class="line">    local_hist_g = clahe.apply(g)</span><br><span class="line">    local_hist_r = clahe.apply(r)</span><br><span class="line">    <span class="keyword">return</span> cv2.merge([local_hist_b, local_hist_g, local_hist_r])</span><br></pre></td></tr></table></figure><h1 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hybrid_ans = hybrid(<span class="string">&#x27;left.jpg&#x27;</span>, <span class="string">&#x27;right.jpg&#x27;</span>, <span class="number">15</span>, <span class="number">10</span>, <span class="number">0.6</span>)</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;hybrid.jpg&#x27;</span>, hybrid_ans)</span><br><span class="line">left_img = cv2.imread(<span class="string">&#x27;left.jpg&#x27;</span>)</span><br><span class="line">right_img = cv2.imread(<span class="string">&#x27;right.jpg&#x27;</span>)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;Left Image&#x27;</span>, left_img)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;Right Image&#x27;</span>, right_img)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;Hybrid Image&#x27;</span>, hybrid_ans)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p>No operation (Original hybrid image).</p><blockquote><p><img src="https://cdn.staticaly.com/gh/albedo-wang/picgo@main/img/Original%20Image.png" alt="Original Image"></p></blockquote><p>Global equalize-hist.</p><blockquote><p><img src="https://cdn.staticaly.com/gh/albedo-wang/picgo@main/img/Global%20Hist%20Image.png" alt="Global Hist Image"></p></blockquote><p>Local equalize-hist.</p><blockquote><p><img src="https://cdn.staticaly.com/gh/albedo-wang/picgo@main/img/Local%20Hist%20Image.png" alt="Local Hist Image"></p></blockquote><p>​        Compare the above three images, we can find that the local equalize-hist is the best! Original one and the global equalize-hist one are extreme in the contrast ratio.</p><p>​        So, the final code choose the local equalize-hist method.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h1&gt;&lt;p&gt;​        The goal of this assignment is to wri</summary>
      
    
    
    
    <category term="视觉" scheme="https://wangqiumimao.ink/categories/%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="CV" scheme="https://wangqiumimao.ink/tags/CV/"/>
    
  </entry>
  
  <entry>
    <title>初来乍到</title>
    <link href="https://wangqiumimao.ink/posts/a28d2e0f.html"/>
    <id>https://wangqiumimao.ink/posts/a28d2e0f.html</id>
    <published>2022-08-11T05:43:30.000Z</published>
    <updated>2023-01-10T03:39:02.963Z</updated>
    
    <content type="html"><![CDATA[<div class="tip bolt"><p>“欲买桂花同载酒，终不似，少年游. ”</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;tip bolt&quot;&gt;&lt;p&gt;“欲买桂花同载酒，终不似，少年游. ”&lt;/p&gt;
&lt;/div&gt;
</summary>
      
    
    
    
    <category term="随记" scheme="https://wangqiumimao.ink/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
    <category term="小纸条" scheme="https://wangqiumimao.ink/tags/%E5%B0%8F%E7%BA%B8%E6%9D%A1/"/>
    
  </entry>
  
</feed>
